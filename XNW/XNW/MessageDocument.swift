//
//  MessageDocument.swift
//  XNW
//
//  Created by Daryle Walker on 1/7/17.
//  Copyright Â© 2017 Daryle Walker. All rights reserved.
//

import Cocoa
import CoreData
import InternetMessages
import InternetMessagesSupport


class MessageDocument: NSDocument {

    enum Names {
        static let internationalEmailMessageUTI = Bundle.main.bundleIdentifier! + ".email"
        static let traditionalEmailMessageUTI = "com.apple.mail.email"
        static let messageModelBundleResource = "RawMessagesModel"
    }

    // MARK: Properties

    /// Specifies an in-memory store for the message data.
    private static let storeDescription: NSPersistentStoreDescription = {
        let description = NSPersistentStoreDescription(url: URL(string: "file:///dev/null")!)
        description.url = nil
        description.type = NSInMemoryStoreType
        return description
    }()
    /// A random name tag for the data container.
    private static let containerName = String(describing: MessageDocument.self)
    /// Specifies the model for the message data.
    private static let messageModel: NSManagedObjectModel = {
        let modelBundle = Bundle(for: RawMessage.self)
        let modelURL = modelBundle.url(forResource: Names.messageModelBundleResource, withExtension: "momd")!
        return NSManagedObjectModel(contentsOf: modelURL)!
    }()

    /// The data stack for the message.
    let container: NSPersistentContainer
    /// The message.
    dynamic var message: RawMessage!
    /// The last error generated by `init()`, which can't throw errors.
    fileprivate var initError: Error?

    // MARK: Overrides

    override init() {
        self.container = NSPersistentContainer(name: MessageDocument.containerName, managedObjectModel: MessageDocument.messageModel)
        super.init()

        // Override the store type and initialize the Core Data stack.
        self.container.persistentStoreDescriptions = [MessageDocument.storeDescription]
        self.container.loadPersistentStores { (storeDescription, error) in
            if let error = error {
                self.initError = error
            }
        }

        // Finish preparing the main context and seed the root message object.
        let mainContext = self.container.viewContext
        mainContext.performAndWait {
            self.message = RawMessage(context: mainContext)
            do {
                try mainContext.save()
            } catch let saveError {
                self.initError = saveError
            }
        }
        mainContext.automaticallyMergesChangesFromParent = true
        mainContext.undoManager = self.undoManager
    }

    override func makeWindowControllers() {
        self.makeMessageWindow()
    }

    override func data(ofType typeName: String) throws -> Data {
        // Get a copy of the message before any main-thread actions could change it.
        var backgroundMessage: RawMessage!
        let backgroundContext = self.container.newBackgroundContext()
        backgroundContext.performAndWait {
            backgroundMessage = backgroundContext.object(with: self.message.objectID) as! RawMessage
        }
        self.unblockUserInteraction()

        // Do the type check after unlocking the main thread; don't risk deadlocking the app.
        let isTypeIntlEmail = UTTypeConformsTo(typeName as CFString, Names.internationalEmailMessageUTI as CFString)
        let isTypeRTF = UTTypeConformsTo(typeName as CFString, kUTTypeRTF)
        guard isTypeIntlEmail || isTypeRTF else { throw CocoaError(.fileWriteUnknown) }

        // Extract the raw data from the message.
        var messageData: Data?
        var backgroundError: Error?
        backgroundContext.performAndWait {
            if isTypeIntlEmail {
                messageData = backgroundMessage.messageAsExternalData
            }
            if isTypeRTF {
                let operation = ConvertMessageToAttributedStringOperation(message: backgroundMessage)
                operation.start()
                if operation.isCancelled {
                    backgroundError = CocoaError(.userCancelled)
                } else {
                    do {
                        let string = operation.messageString
                        try messageData = string.data(from: NSMakeRange(0, string.length), documentAttributes: [NSDocumentTypeDocumentAttribute: NSRTFTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8])
                    } catch {
                        backgroundError = error
                    }
                }
            }
        }
        if let error = backgroundError {
            throw error
        }
        return messageData!
    }

    override func read(from data: Data, ofType typeName: String) throws {
        let isTypeIntlEmail = UTTypeConformsTo(typeName as CFString, Names.internationalEmailMessageUTI as CFString)
        let isTypeClassicEmail = UTTypeConformsTo(typeName as CFString, Names.traditionalEmailMessageUTI as CFString)
        guard isTypeIntlEmail || isTypeClassicEmail else { throw CocoaError(.fileReadUnknown) }

        // Parse the incoming data.
        let operationalMessage = InternetMessageReadingOperation(data: data)
        operationalMessage.start()
        assert(operationalMessage.isFinished)
        guard !operationalMessage.isCancelled else { throw CocoaError(.userCancelled) }

        // Create a document message object from the operation message object.
        var backgroundMessage: RawMessage!
        var backgroundError: Error?
        let backgroundContext = self.container.newBackgroundContext()
        backgroundContext.performAndWait {
            backgroundMessage = RawMessage(context: backgroundContext)
            for field in operationalMessage.header {
                let fieldObject = RawHeaderField(context: backgroundContext)
                fieldObject.name = field.name
                fieldObject.body = field.body
                fieldObject.message = backgroundMessage
            }
            backgroundMessage.body = operationalMessage.body

            do {
                try backgroundContext.save()
            } catch {
                backgroundError = error
            }
        }
        guard backgroundError == nil else { throw backgroundError! }

        // Replace the current message with a copy of the new one.
        let mainContext = self.container.viewContext
        mainContext.performAndWait {
            self.undoManager?.disableUndoRegistration()
            defer { self.undoManager?.enableUndoRegistration() }

            let oldMessage = self.message
            self.message = mainContext.object(with: backgroundMessage.objectID) as! RawMessage
            mainContext.delete(oldMessage!)
            try! mainContext.save()  // Can't really recover; the new message is already in.
        }
    }

    override class func autosavesInPlace() -> Bool {
        return true
    }

    override var autosavingFileType: String? {
        return Names.internationalEmailMessageUTI
    }

    override func canAsynchronouslyWrite(to url: URL, ofType typeName: String, for saveOperation: NSSaveOperationType) -> Bool {
        let isTypeIntlEmail = UTTypeConformsTo(typeName as CFString, Names.internationalEmailMessageUTI as CFString)
        let isTypeRTF = UTTypeConformsTo(typeName as CFString, kUTTypeRTF)
        if isTypeIntlEmail || isTypeRTF {
            return true
        } else {
            return super.canAsynchronouslyWrite(to: url, ofType: typeName, for: saveOperation)
        }
    }

    override class func canConcurrentlyReadDocuments(ofType typeName: String) -> Bool {
        let isTypeIntlEmail = UTTypeConformsTo(typeName as CFString, Names.internationalEmailMessageUTI as CFString)
        let isTypeClassicEmail = UTTypeConformsTo(typeName as CFString, Names.traditionalEmailMessageUTI as CFString)
        if isTypeIntlEmail || isTypeClassicEmail {
            return true
        } else {
            return super.canConcurrentlyReadDocuments(ofType: typeName)
        }
    }

    override func save(to url: URL, ofType typeName: String, for saveOperation: NSSaveOperationType, completionHandler: @escaping (Error?) -> Void) {
        // Save the message data to the store so any background contexts can read the data later.
        let mainContext = self.container.viewContext
        var gotError = false
        mainContext.performAndWait {
            do {
                try mainContext.save()
            } catch {
                completionHandler(error)
                gotError = true
            }
        }
        guard !gotError else { return }

        // Do the usual code, possibly even use a background thread.
        super.save(to: url, ofType: typeName, for: saveOperation, completionHandler: completionHandler)
    }

    override func printOperation(withSettings printSettings: [String : Any]) throws -> NSPrintOperation {
        // Copy the message to a string to print.
        var messageString: NSAttributedString!
        var error: Error?
        let mainContext = self.container.viewContext
        mainContext.performAndWait {
            let operation = ConvertMessageToAttributedStringOperation(message: self.message)
            operation.start()
            if operation.isCancelled {
                error = CocoaError(.userCancelled)
            } else {
                messageString = operation.messageString
            }
        }
        guard error == nil else { throw error! }

        // Create a view to visualize the message string.
        var info = self.printInfo.copy() as! NSPrintInfo
        info.dictionary().addEntries(from: printSettings)
        info.isHorizontallyCentered = false
        info.isVerticallyCentered = false

        let marginRect = NSRect(x: info.leftMargin, y: info.bottomMargin, width: info.paperSize.width - info.leftMargin - info.rightMargin, height: info.paperSize.height - info.bottomMargin - info.topMargin)
        let view = NSTextView(frame: info.imageablePageBounds.intersection(marginRect))
        view.autoresizingMask = [.viewWidthSizable, .viewHeightSizable]
        do {
            view.textStorage?.beginEditing()
            defer { view.textStorage?.endEditing() }

            view.textStorage?.setAttributedString(messageString)
        }

        return NSPrintOperation(view: view, printInfo: info)
    }

}

// MARK: Initializer Overloads

extension MessageDocument {

    /// Recreate the initializer with a type name, plus extra error-checking from `init`.
    convenience init(type typeName: String) throws {
        self.init()
        guard self.initError == nil else { throw self.initError! }

        // Recreate the algorithm from super, since Swift's rules prevent me from calling it directly.
        self.fileType = typeName
    }

    /// Recreate the initializer with a URL and type name, plus extra error-checking from `init`.
    convenience init(contentsOf url: URL, ofType typeName: String) throws {
        self.init()
        guard self.initError == nil else { throw self.initError! }

        // Recreate the algorithm from super, since Swift's rules prevent me from calling it directly.
        try self.read(from: url, ofType: typeName)
        self.fileURL = url
        self.fileType = typeName
        self.fileModificationDate = try FileManager.default.attributesOfItem(atPath: url.path)[.modificationDate] as? Date
    }

    /// Recreate the initializer with an alternate URL, plus extra error-checking from `init`.
    convenience init(for urlOrNil: URL?, withContentsOf contentsURL: URL, ofType typeName: String) throws {
        self.init()
        guard self.initError == nil else { throw self.initError! }

        // Recreate the algorithm from super, since Swift's rules prevent me from calling it directly.
        try self.read(from: contentsURL, ofType: typeName)
        self.fileURL = urlOrNil
        self.autosavedContentsFileURL = contentsURL
        self.fileType = typeName
        self.fileModificationDate = try FileManager.default.attributesOfItem(atPath: (urlOrNil ?? contentsURL).path)[.modificationDate] as? Date
        if urlOrNil != contentsURL {
            self.updateChangeCount(.changeReadOtherContents)
        }

        // Reset the file type if it was imported from auto-save.
        if let allegedSourceFileURL = urlOrNil {
            self.fileType = try NSDocumentController.shared().typeForContents(of: allegedSourceFileURL)
        }
    }

}

// MARK: Window Creation

extension MessageDocument {

    /// Create a window (and controller) for messages.
    func makeMessageWindow() {
        let storyboard = NSStoryboard(name: MessageWindowController.Names.storyboard, bundle: nil)
        let controller = storyboard.instantiateInitialController() as! MessageWindowController
        controller.bind(#keyPath(MessageWindowController.representedMessage), to: self, withKeyPath: #keyPath(message))  // Undone in window controller.
        controller.bind(#keyPath(MessageWindowController.isWritable), to: self, withKeyPath: #keyPath(isInViewingMode), options: [NSValueTransformerNameBindingOption: NSValueTransformerName.negateBooleanTransformerName])  // Undone in window controller.
        self.addWindowController(controller)
    }

}

// MARK: - Actions

extension MessageDocument {

    /// Add an empty string as the message body if it doesn't exist yet.
    @IBAction func addBody(_ sender: Any) {
        guard self.message.body == nil else { return }

        self.message.body = ""
    }

    /// Remove the message body.
    @IBAction func removeBody(_ sender: Any) {
        Swift.print("\(#function) activated.")
        self.message.body = nil
    }

}
